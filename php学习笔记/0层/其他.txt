1、类型转换（隐性和显性）
2、opcache  字节码，也叫操作码，是一种中间码
3、浅拷贝和深拷贝
4、ArrayAccess（数组式访问）接口
5、迭代器
6、生成随机数
7、二进制安全 ？
8、线性安全  ？
9、修饰符
10、常用的指标和极限
11、XML、Sockect/GD/ImageMgk
12、SPL
13、连接池编写（）



学院君有最好的各种教程  比如
https://xueyuanjun.com/books/network-protocols

ArrayAccess（数组式访问）接口
迭代器
生成随机数

https://segmentfault.com/a/1190000010262869
https://www.jianshu.com/p/e0b1740aff0b


浅拷贝和深拷贝
深拷贝：赋值时值完全复制，完全的copy，对其中一个作出改变，不会影响另一个
浅拷贝：赋值时，引用赋值，相当于取了一个别名。对其中一个修改，会影响另一个
PHP中， = 赋值时，普通对象是深拷贝，但对对象来说，是浅拷贝。也就是说，对象的赋值是引用赋值。（对象作为参数传递时，也是引用传递，无论函数定义时参数前面是否有&符号）
但是clone函数存在这么一个问题，克隆对象时，原对象的普通属性能值复制，但是源对象的对象属性赋值时还是引用赋值，浅拷贝。
实现深拷贝：
第一种方法　改写__clone()
第二种方法，利用序列化反序列化实现,这种方法实现对象的深拷贝简单，不需要修改类。
class Test{
    public $a=1;
}
class TestOne{
    public $b=1;
    public $obj;
    //包含了一个对象属性，clone时，它会是浅拷贝
    public function __construct(){
        $this->obj = new Test();
    }   
}
$m = new TestOne();
//方法二，序列化反序列化实现对象深拷贝
$n = serialize($m);
$n = unserialize($n);
$n->b = 2;
echo $m->b;//输出原来的1
echo PHP_EOL;
//可以看到，普通属性实现了深拷贝，改变普通属性b，不会对源对象有影响
$n->obj->a = 3;
echo $m->obj->a;//输出1，不随新对象改变，还是保持了原来的属性,可以看到，序列化和反序列化可以实现对象的深拷贝
还有第三种方法，其实和第二种类似，json_encode之后再json_decode,实现赋值　


大括号使用：
二、$str{4}在字符串的变量的后面跟上{}大括号和中括号[]一样都是把某个字符串变量当成数组处理。

三、{$val}这种情况就是我遇到的问题，这时候大括号起的作用就是，告诉PHP，括起来的要当成变量处理。

如果要检查某个字符串是否满足多少长度，可以考虑用这种大括号（花括号）加 isset 的方式替代 strlen 函数，因为 isset 是语言结构，strlen 是函数，所以使用 isset 比使用 strlen 效率更高。
比如判断一个字符串的长度是否小于 5：
if  ( !isset ( $str{5} ) ) 就比 if  ( strlen ( $str ) < 5 ) 好。

1. 动态设置对象的属性名的使用：
写法一（不能正确设置）：

$obj->$string[$key]; //这里只能使用$string的0位置的字符作为属性名值，如：$string = 'string'; $obj->$string[$key] 等同于$obj->s[$key];

写法二（可以正确设置）：

    $obj->{$string}[$key]; //这里的大括号有点类似于运算中的小括号的作用，即先算大括号里面的内容。但是请注意：

写法三（错误的写法）：

    $obj->($string)[$key]; // 直接报错

2. 检测字符串的长度中使用：

    $string = 'string';
    if(isset($string{8})) {
    echo 'Is set!';
    } else {
    echo 'Not set!';
    }

3. 像字符串中使用变量的时候也要用到，如：

    echo "{$string}, {$obj->string}";
	
	
 get_class_vars 和get_object_vars的区别：
注意： get_class_vars 获取的属性的值是初始化的默认值，不是运行过程中，更改的值。
class Girl
 4 {
 5     public $id = 1;
 6     public $name = 'zhy';
 7 }
 8 
 9 $girl = new Girl();
10 var_dump(get_class_vars(get_class($girl)));
11 
12 $girl->c = 20;
13 var_dump(get_object_vars(($girl)));

线性安全
在单线程环境中，我们经常使用全局变量实现多个函数间数据共享，声明函数之外的变量为全局变量，全局变量为各线程共享，不同的线程引用同一地址空间，如果一个线程修改了全局变量就会影响到所有的线程。
因此：线程安全（TSRM）就是指多线程环境下如何安全的获取公共的资源。
在多线程的环境下使用全局变量，将会引起线程之间的冲突，因此，php实现了一个线程安全资源管理器（Thread Safe Resource Manager 简称TSRM），用于解决多线程环境下公共资源冲突的问题，实现线程之间安全的操作公共资源。

二进制安全
解释一：
　　PHP里，有string的概念。
　　string里，每个字符的大小为byte（与PHP相比，Java的每个字符为Character，是UTF8字符，C语言的每个字符可以在编译时选择）。
byte里，有ASCII代码的字符，例如ABC，123，abc，也有一些特殊字符，例如回车，退格之类的。
特殊字符很多是不能显示的。或者说，他们的显示方式没有标准，例如编码65到哪儿都是字母A，编码97到哪儿都是字符a，退格在有的地方显示成一个符号，在有的地方就会真的把前一个字符退掉。
　　PHP以C为基础，所以很多描述都是以C为对比。C的字符串里，一种经典的定义就是，以编码0作为字符串的结尾。那么，假设这样一个string，里面3个字符的编码分别是97，0，97。那么，C里面如果有str_replace等效的函数， 利用它把97换成98，那么这个函数读取到0的时候，就认为已经结束了，就会得到98,0,97。跟它对应的，PHP里的str_replace是二进制安全的，那么这个0不会被视为特殊的结束符号，于是结果就是98，0，98。
　　【二进制安全】在PHP文档里，基本就是这么一个意思：C语言里的功能类似的函数会对有的字符特别处理，而PHP这个函数对于所有字符一视同仁，不用担心会有特殊字符影响处理，特别不用担心编码0字符。
解释二：
　　c中的strlen函数就不算是binary safe的，因为它依赖于特殊的字符'\0'来判断字符串是否结束，
所以对于字符串str = "1234\0123"来说，strlen(str)=4
　　而在php中，strlen函数是binary safe的，因为它不会对任何字符（包括'\0'）进行特殊解释，
所以在php中，strlen(str)=8
　　所以，我理解的二进制安全的意思是：只关心二进制化的字符串,不关心具体格式，
只会严格的按照二进制的数据存取。不会妄图已某种特殊格式解析数据

