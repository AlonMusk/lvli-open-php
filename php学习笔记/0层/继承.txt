众所周知，面向对象的编程语言有三大特性，分别是：封装、继承和多态。

面向对象的封装特性就是将类中的成员属性和方法内容细节尽可能地隐藏起来，确保类外部代码不能随意访问类中的内容。

面向对象的继承特性使得子类可继承父类中的属性和方法，提高类代码的复用性。

面向对象的多态特性是最常用到的一种特性。所谓多态，是指同一个东西不同形态的展示。


继承：继承使用关键字extends进行继承的。可以理解为代码的复用，但是如果父类的属性或者方法被private修饰，则子类不能够继承，子类最多只能继承一个父类(指直接继承)，在创建某个子类对象时，默认情况下会自动调用其父类的构造函数(指在子类没有自定义构造函数情况时)

(1) 接口的继承
接口自身也允许多继承，但是父子之间方法不能同名 interface Person extends Human,People
类与接口之间允许多继承  class E implements A,B 

(2) 抽象类/普通类的继承
类只能实现单继承

多态：同一个实体同时具有多种形式，使用类型约束，根据传入的对象类型不同，调用对应对象的方法


重载：简单说，就是函数或者方法有相同的名称，但是参数列表不相同的情形，这样的同名不同参数的函数或者方法之间，互相称之为重载函数或者方法。
方法的重载：
上面的关于方法的重载可以理解为在一个类中，有两个方法名一样的函数，但是函数的参数是不一样的，我们在调用的时候，系统会根据我们传入的参数的不同，而自动的调用不同的函数，这就是重载，但是在PHP中一个类中不能有两个方法名相同的函数，尽管你的参数不同，它会报一个Cannot redeclare的错误。那么在PHP中就不能重载了吗？其实可以的，利用魔术方法。
  class Calculate{

        //定义两个方法，计算加法，注意两个方法的方法名是不一样的
        private function add($a,$b,$c){ 
            return $a + $b + $c;
        }

        private function add1($a,$b){
            return $a + $b;
        }

        public function __call($name,$val_arr){
            if($name == 'add'){
                //得到数组里面的参数，确定几个参数
                $num = count($val_arr);
                if($num == 2){
                    return $this -> add1($val_arr[0],$val_arr[1]);
                }else if($num == 3){
                    return $this -> add($val_arr[0],$val_arr[1],$val_arr[2]);
                }
            }
        }
    }

    $calculate = new Calculate();
    echo $calculate -> add(1,2);
    echo '<br>';
    echo $calculate -> add(1,2,3);
    .....结果......
    3
    6
看到代码有没有被欺骗的感觉-_-,先把类中的两个方法设置成private，这样在类外就访问不到，当我们在类外访问add方法的时候，会调用魔术方法，然后通过传入的数组的个数，确定参数的个数，从而在魔术方法中去掉用合适的方法。这就是PHP的方法重载。

属性重载：在PHP面向对象编程中，当你去给一个不存在的属性赋值时，PHP默认会’动态的’, 给你创建一个对应的属性，这个称为属性重载。
class A{
        //在类中只定义一个变量
        public $name = '小明';

    }
    $a = new A();
    echo '<pre>';
    var_dump($a);
    $a -> age = 12;
    var_dump($a);
    .....结果......
    object(A)#1 (1) {
      ["name"]=>
      string(6) "小明"
    }
    object(A)#1 (2) {
      ["name"]=>
      string(6) "小明"
      ["age"]=>
      int(12)
    }
从结果中可以看到，当我们给一个不存在属性age赋值后，在输出的类结构中出现了age这个属性，这就是属性的重载。
如果不想让类的属性自动增加，可以使用魔术方法__set()和__get()方法进行控制。


在上节中介绍魔术方法中有一个方法是当我们访问不可访问或不存在的方法时，系统自动调用的，也就是__call()方法。PHP中可以利用这个魔术方法进行重载


重写：如果子类中的方法和父类方法相同，我们称为方法重写。
方法的重写：
如果父类的方法中使用了类型约束,那么子类的类型约束也必须一样。
在方法的重写中：
子类的方法的参数个数 ,方法名称,要和父类方法的参数个数,方法名称一样
子类方法不能缩小父类方法的访问权限(可以大于可以等于)
注意：如果父类的方法名是private，则子类并不会进行重写。

属性的重写：
对于属性的重写也是，public 和 protected 可以被重写，private 的属性不能被重写
 class Animal{
        public $name = '小花';
        protected $age = 12;
        private $sex = '雄';
    }

    class Cat extends Animal{
        public $name = '小白';
        protected $age = 4;
        private $sex = '雄';
    }
    $cat = new Cat();
    echo '<pre>';
    var_dump($cat);
    ......结果......
    object(Cat)#1 (4) {
      ["name"]=>
      string(6) "小白"
      ["age":protected]=>
      int(4)
      ["sex":"Cat":private]=>
      string(3) "雄"
      ["sex":"Animal":private]=>
      string(3) "雄"
    }

克隆：为什么要把克隆放在这里。PHP5中有个非常重要的改变，使用new关键字
new出的对象是一个指向对象句柄的id，当赋值给其他变量的时候，会有意想不到的结果

封装的实现，可以降低代码的耦合度，同时继承的时候减少代码的冗余度