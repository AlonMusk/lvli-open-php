时间复杂度
空间复杂度

十大经典排序算法
1、冒泡排序
2、选择排序
3、插入排序
4、希尔排序
5、归并排序
6、快速排序
7、堆排序
8、计数排序
9、桶排序
10、基数排序

冒泡算法
function bubbleSort($arr)
{
    $len = count($arr);
    for ($i = 0; $i < $len - 1; $i++) {
        for ($j = 0; $j < $len - 1 - $i; $j++) {
            if ($arr[$j] > $arr[$j+1]) {
                $tmp = $arr[$j];
                $arr[$j] = $arr[$j+1];
                $arr[$j+1] = $tmp;
            }
        }
    }
    return $arr;
}

选择排序
function selectionSort($arr)
{
    $len = count($arr);
    for ($i = 0; $i < $len - 1; $i++) {
        $minIndex = $i;
        for ($j = $i + 1; $j < $len; $j++) {
            if ($arr[$j] < $arr[$minIndex]) {
                $minIndex = $j;
            }
        }
        $temp = $arr[$i];
        $arr[$i] = $arr[$minIndex];
        $arr[$minIndex] = $temp;
    }
    return $arr;
}

插入排序
function insertionSort($arr)
{
    $len = count($arr);
    for ($i = 1; $i < $len; $i++) {
        $preIndex = $i - 1;
        $current = $arr[$i];
        while($preIndex >= 0 && $arr[$preIndex] > $current) {
            $arr[$preIndex+1] = $arr[$preIndex];
            $preIndex--;
        }
        $arr[$preIndex+1] = $current;
    }
    return $arr;
}

希尔排序
是插入排序的一种更高效的改进版本
希尔排序的基本思想是：先将整个待排序的记录序列分割成为若干子序列分别进行直接插入排序，待整个序列中的记录"基本有序"时，再对全体记录进行依次直接插入排序。
function shellSort($arr)
{
    $len = count($arr);
    $temp = 0;
    $gap = 1;
    while($gap < $len / 3) {
        $gap = $gap * 3 + 1;
    }
    for ($gap; $gap > 0; $gap = floor($gap / 3)) {
        for ($i = $gap; $i < $len; $i++) {
            $temp = $arr[$i];
            for ($j = $i - $gap; $j >= 0 && $arr[$j] > $temp; $j -= $gap) {
                $arr[$j+$gap] = $arr[$j];
            }
            $arr[$j+$gap] = $temp;
        }
    }
    return $arr;
}

归并排序
function mergeSort($arr)
{
    $len = count($arr);
    if ($len < 2) {
        return $arr;
    }
    $middle = floor($len / 2);
    $left = array_slice($arr, 0, $middle);
    $right = array_slice($arr, $middle);
    return merge(mergeSort($left), mergeSort($right));
}

function merge($left, $right)
{
    $result = [];

    while (count($left) > 0 && count($right) > 0) {
        if ($left[0] <= $right[0]) {
            $result[] = array_shift($left);
        } else {
            $result[] = array_shift($right);
        }
    }

    while (count($left))
        $result[] = array_shift($left);

    while (count($right))
        $result[] = array_shift($right);

    return $result;
}

快速排序
快速排序应该算是在冒泡排序基础上的递归分治法。
function quickSort($arr)
{
    if (count($arr) <= 1)
        return $arr;
    $middle = $arr[0];
    $leftArray = array();
    $rightArray = array();

    for ($i = 1; $i < count($arr); $i++) {
        if ($arr[$i] > $middle)
            $rightArray[] = $arr[$i];
        else
            $leftArray[] = $arr[$i];
    }
    $leftArray = quickSort($leftArray);
    $leftArray[] = $middle;

    $rightArray = quickSort($rightArray);
    return array_merge($leftArray, $rightArray);
}

堆排序
堆排序可以说是一种利用堆的概念来排序的选择排序。分为两种方法：
大顶堆：每个节点的值都大于或等于其子节点的值，在堆排序算法中用于升序排列；
小顶堆：每个节点的值都小于或等于其子节点的值，在堆排序算法中用于降序排列；
function buildMaxHeap(&$arr)
{
    global $len;
    for ($i = floor($len/2); $i >= 0; $i--) {
        heapify($arr, $i);
    }
}

function heapify(&$arr, $i)
{
    global $len;
    $left = 2 * $i + 1;
    $right = 2 * $i + 2;
    $largest = $i;

    if ($left < $len && $arr[$left] > $arr[$largest]) {
        $largest = $left;
    }

    if ($right < $len && $arr[$right] > $arr[$largest]) {
        $largest = $right;
    }

    if ($largest != $i) {
        swap($arr, $i, $largest);
        heapify($arr, $largest);
    }
}

function swap(&$arr, $i, $j)
{
    $temp = $arr[$i];
    $arr[$i] = $arr[$j];
    $arr[$j] = $temp;
}

function heapSort($arr) {
    global $len;
    $len = count($arr);
    buildMaxHeap($arr);
    for ($i = count($arr) - 1; $i > 0; $i--) {
        swap($arr, 0, $i);
        $len--;
        heapify($arr, 0);
    }
    return $arr;
}

计数排序
function countingSort($arr, $maxValue = null)
{
    if ($maxValue === null) {
        $maxValue = max($arr);
    }
    for ($m = 0; $m < $maxValue + 1; $m++) {
        $bucket[] = null;
    }

    $arrLen = count($arr);
    for ($i = 0; $i < $arrLen; $i++) {
        if (!array_key_exists($arr[$i], $bucket)) {
            $bucket[$arr[$i]] = 0;
        }
        $bucket[$arr[$i]]++;
    }

    $sortedIndex = 0;
    foreach ($bucket as $key => $len) {
        if ($len !== null) $arr[$sortedIndex++] = $key;
        if($len !== null){
            for($j = 0; $j < $len; $j++){
                $arr[$sortedIndex++] = $key;
            }
        }
    }

    return $arr;
}

桶排序是计数排序的升级版。
function bucketSort($arr, $bucketSize = 5)
{
    if (count($arr) === 0) {
      return $arr;
    }

    $minValue = $arr[0];
    $maxValue = $arr[0];
    for ($i = 1; $i < count($arr); $i++) {
      if ($arr[$i] < $minValue) {
          $minValue = $arr[$i];
      } else if ($arr[$i] > $maxValue) {
          $maxValue = $arr[$i];
      }
    }

    $bucketCount = floor(($maxValue - $minValue) / $bucketSize) + 1;
    $buckets = array();
    for ($i = 0; $i < count($buckets); $i++) {
        $buckets[$i] = [];
    }

    for ($i = 0; $i < count($arr); $i++) {
        $buckets[floor(($arr[$i] - $minValue) / $bucketSize)][] = $arr[$i];
    }

    $arr = array();
    for ($i = 0; $i < count($buckets); $i++) {
        $bucketTmp = $buckets[$i];
        sort($bucketTmp);
        for ($j = 0; $j < count($bucketTmp); $j++) {
            $arr[] = $bucketTmp[$j];
        }
    }

    return $arr;
}

基数排序是一种非比较型整数排序算法，其原理是将整数按位数切割成不同的数字，然后按每个位数分别比较。由于整数也可以表达字符串（比如名字或日期）和特定格式的浮点数，所以基数排序也不是只能使用于整数。
1. 基数排序 vs 计数排序 vs 桶排序
基数排序有两种方法：

这三种排序算法都利用了桶的概念，但对桶的使用方法上有明显差异：
基数排序：根据键值的每位数字来分配桶；
计数排序：每个桶只存储单一键值；
桶排序：每个桶存储一定范围的数值；
function radixSort($arr, $maxDigit = null)
{
    if ($maxDigit === null) {
        $maxDigit = max($arr);
    }
    $counter = [];
    for ($i = 0; $i < $maxDigit; $i++) {
        for ($j = 0; $j < count($arr); $j++) {
            preg_match_all('/\d/', (string) $arr[$j], $matches);
            $numArr = $matches[0];
            $lenTmp = count($numArr);
            $bucket = array_key_exists($lenTmp - $i - 1, $numArr)
                ? intval($numArr[$lenTmp - $i - 1])
                : 0;
            if (!array_key_exists($bucket, $counter)) {
                $counter[$bucket] = [];
            }
            $counter[$bucket][] = $arr[$j];
        }
        $pos = 0;
        for ($j = 0; $j < count($counter); $j++) {
            $value = null;
            if ($counter[$j] !== null) {
                while (($value = array_shift($counter[$j])) !== null) {
                    $arr[$pos++] = $value;
                }
          }
        }
    }

    return $arr;
}


二分查找
/**

* 二分算法查找

* @param array $array 要查找的数组

* @param int $min_key 数组的最小下标

* @param int $max_key 数组的最大下标

* @param mixed $value 要查找的值

* @return boolean

*/ function bin_search($array,$min_key,$max_key,$value){             

    if($min_key <= $max_key){

        $key = intval(($min_key+$max_key)/2);

        if($array[$key] == $value){

            return true;

        }elseif($value < $array[$key]){

            return bin_search($array,$min_key,$key-1,$value);

        }else{

            return bin_search($array,$key+1,$max_key,$value);

        }  

    }else{     

        return false;  

    }

}




线性表删除
function delete_array_element($array, $i)   {  

    $len = count($array);  

    for ($j=$i; $j<$len; $j++){     

        $array[$j] = $array[$j+1]  

    }  

    array_pop($array); 

    return $array;

}

字符串长度
function strlen($str)   {

    if ($str == '') return 0;

    $count = 0;

    while (1){

        if ($str[$count] != NULL){

            $count++;

            continue;

        }else{

            break;

        }

    }

    return $count;

}

字符串翻转
function strrev($str)   {  

    if ($str == '') return 0;  

    for ($i=(strlen($str)-1); $i>=0; $i--){  

        $rev_str .= $str[$i];  

    }  

    return $rev_str;

}

字符串比较
function strcmp($s1, $s2)   {

    if (strlen($s1) < strlen($s2)) return -1;

    if (strlen($s1) > strlen($s2)) return 1;

    for ($i=0; $i
        if ($s1[$i] == $s2[$i]){

            continue;

        }else{         

            return false;

        }  

    }  

    return 0;

}

查找字符串
function strstr($str, $substr)  {

    $m = strlen($str);

    $n = strlen($substr);

    if ($m < $n) return false;

    for ($i=0; $i<=($m-$n+1); $i++){

        $sub = substr($str, $i, $n);

        if (strcmp($sub, $substr) == 0) return $i;

    }

    return false;

}

字符串替换
function str_replace($substr, $newsubstr, $str) {

    $m = strlen($str);

    $n = strlen($substr);

    $x = strlen($newsubstr);

    if (strchr($str, $substr) == false) return false;

    for ($i=0; $i<=($m-$n+1); $i++){

        $i = strchr($str, $substr);

        $str = str_delete($str, $i, $n);

        $str = str_insert($str, $i, $newstr);

    }

    return $str;

}

插入一段字符串
function str_insert($str, $i, $substr)  {

    for($j=0; $j<$i; $j++){

        $startstr .= $str[$j];

    }

    for ($j=$i; $j
        $laststr .= $str[$j];

    }

    $str = ($startstr . $substr . $laststr);

    return $str;

}


删除一段字符串
function str_delete($str, $i, $j){ 

    for ($c=0; $c<$i; $c++){

        $startstr .= $str[$c];

    }

    for ($c=($i+$j); $c
        $laststr .= $str[$c];

    }

    $str = ($startstr . $laststr);

    return $str;

}


复制字符串
function strcpy($s1, $s2){

    if (strlen($s1)==NULL || !isset($s2)) return;

    for ($i=0; $i
        $s2[] = $s1[$i];

    }

    return $s2;

}


连接字符串
function strcat($s1, $s2){

    if (!isset($s1) || !isset($s2)) return;

    $newstr = $s1;

    for($i=0; $i
        $newstr .= $st[$i];

    }

    return $newsstr;

}


编码函数
function php_encode($str) { if ($str=='' && strlen($str)>128) return false; for($i=0; $i31 && $c<107) $c += 20; if ($c>106 && $c<127) $c -= 75; $word = chr($c); $s .= $word; } return $s; }

解码函数
function php_decode($str)   {

    if ($str=='' && strlen($str)>128) return false;

    for($i=0; $i
        $c = ord($word);

        if ($c>106 && $c<127) $c = $c-20;

        if ($c>31 && $c<107) $c = $c+75;

        $word = chr($c);

        $s .= $word;

    }

    return $s;

}

简单加密
function php_encrypt($str)  {  

    $encrypt_key = 'abcdefghijklmnopqrstuvwxyz1234567890';

    $decrypt_key = 'ngzqtcobmuhelkpdawxfyivrsj2468021359'; 

    if (strlen($str) == 0) return false;    

    for ($i=0; $i
        for ($j=0; $j
            if ($str[$i] == $encrypt_key[$j]){  

                $enstr .= $decrypt_key[$j];     

                break;  

            }   

        }   

    }  

    return $enstr;

}

解密函数
function php_decrypt($str)  {

    $encrypt_key = 'abcdefghijklmnopqrstuvwxyz1234567890';

    $decrypt_key = 'ngzqtcobmuhelkpdawxfyivrsj2468021359';

    if (strlen($str) == 0) return false;

    for ($i=0; $i
        for ($j=0; $j
            if ($str[$i] == $decrypt_key[$j]){

                $enstr .= $encrypt_key[$j];

                break;

            }

        }

    }

    return $enstr;

}

