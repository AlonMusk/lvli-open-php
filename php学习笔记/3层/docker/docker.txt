宝塔的运行环境 包括： docker管理器

http://www.ruanyifeng.com/blog/2018/02/docker-tutorial.html
1、环境配置的难题
用户必须保证两件事：操作系统的设置，各种库和组件的安装。
环境配置如此麻烦，换一台机器，就要重来一次，旷日费时。很多人想到，能不能从根本上解决问题，软件可以带环境安装？也就是说，安装的时候，把原始环境一模一样地复制过来。

二：虚拟机
虚拟机（virtual machine）就是带环境安装的一种解决方案。
缺点：
1.资源占用多
虚拟机会独占一部分内存和硬盘空间。它运行的时候，其他程序就不能使用这些资源了。哪怕虚拟机里面的应用程序，真正使用的内存只有 1MB，虚拟机依然需要几百 MB 的内存才能运行。

2.冗余步骤多  
3.启动慢


三、linux容器 LXC（Percona XtraDB Cluster（下文简称PXC集群））
Linux 容器不是模拟一个完整的操作系统，而是对进程进行隔离。或者说，在正常进程的外面套了一个保护层。对于容器里面的进程来说，它接触到的各种资源都是虚拟的，从而实现与底层系统的隔离。

由于容器是进程级别的，相比虚拟机有很多优势。
（1）启动快
容器里面的应用，直接就是底层系统的一个进程，而不是虚拟机内部的进程。所以，启动容器相当于启动本机的一个进程，而不是启动一个操作系统，速度就快很多
（2）资源占用少
（3）体积小

总之，容器有点像轻量级的虚拟机，能够提供虚拟化的环境，但是成本开销小得多。


四、Docker 是什么？
Docker 属于 Linux 容器的一种封装，提供简单易用的容器使用接口。它是目前最流行的 Linux 容器解决方案。
Docker 将应用程序与该程序的依赖，打包在一个文件里面。运行这个文件，就会生成一个虚拟容器。程序在这个虚拟容器里运行，就好像在真实的物理机上运行一样。有了 Docker，就不用担心环境问题。

五、Docker 的用途
（1）提供一次性的环境。比如，本地测试他人的软件、持续集成的时候提供单元测试和构建的环境。

（2）提供弹性的云服务。因为 Docker 容器可以随开随关，很适合动态扩容和缩容。

（3）组建微服务架构。通过多个容器，一台机器可以跑多个服务，因此在本机就可以模拟出微服务架构。

六、image文件
Docker 把应用程序以及其依赖，打包在image文件里面。只有通过这个文件，才能生成 Docker 容器。image 文件可以看作是容器的模板。Docker 根据 image 文件生成容器的实例。同一个 image 文件，可以生成多个同时运行的容器实例。
image 是二进制文件。实际开发中，一个 image 文件往往通过继承另一个 image 文件，加上一些个性化设置而生成。举例来说，你可以在 Ubuntu 的 image 基础上，往里面加入 Apache 服务器，形成你的 image。

八、容器文件
image 文件生成的容器实例，本身也是一个文件，称为容器文件。也就是说，一旦容器生成，就会同时存在两个文件： image 文件和容器文件。

九、Dockerfile文件
学会使用 image 文件以后，接下来的问题就是，如何可以生成 image 文件？如果你要推广自己的软件，势必要自己制作 image 文件。
这就需要用到 Dockerfile 文件。它是一个文本文件，用来配置 image。Docker 根据 该文件生成二进制的 image 文件。

十、实例：制作自己的 Docker 容器
10.1 编写 Dockerfile 文件
首先，在项目的根目录下，新建一个文本文件.dockerignore，写入下面的内容。


.git
node_modules
npm-debug.log
然后，在项目的根目录下，新建一个文本文件 Dockerfile，写入下面的内容。
FROM node:8.4
COPY . /app
WORKDIR /app
RUN npm install --registry=https://registry.npm.taobao.org
EXPOSE 3000
上面代码一共五行，含义如下。

FROM node:8.4：该 image 文件继承官方的 node image，冒号表示标签，这里标签是8.4，即8.4版本的 node。
COPY . /app：将当前目录下的所有文件（除了.dockerignore排除的路径），都拷贝进入 image 文件的/app目录。
WORKDIR /app：指定接下来的工作路径为/app。
RUN npm install：在/app目录下，运行npm install命令安装依赖。注意，安装后所有的依赖，都将打包进入 image 文件。
EXPOSE 3000：将容器 3000 端口暴露出来， 允许外部连接这个端口。

10.2 创建 image 文件
有了 Dockerfile 文件以后，就可以使用docker image build命令创建 image 文件了。


$ docker image build -t koa-demo .
# 或者
$ docker image build -t koa-demo:0.0.1 .
上面代码中，-t参数用来指定 image 文件的名字，后面还可以用冒号指定标签。如果不指定，默认的标签就是latest。最后的那个点表示 Dockerfile 文件所在的路径，上例是当前路径，所以是一个点。

如果运行成功，就可以看到新生成的 image 文件koa-demo了。
$ docker image ls

10.3 生成容器
docker container run命令会从 image 文件生成容器。
$ docker container run -p 8000:3000 -it koa-demo /bin/bash
# 或者
$ docker container run -p 8000:3000 -it koa-demo:0.0.1 /bin/bash
上面命令的各个参数含义如下：
-p参数：容器的 3000 端口映射到本机的 8000 端口。
-it参数：容器的 Shell 映射到当前的 Shell，然后你在本机窗口输入的命令，就会传入容器。
koa-demo:0.0.1：image 文件的名字（如果有标签，还需要提供标签，默认是 latest 标签）。
/bin/bash：容器启动以后，内部第一个执行的命令。这里是启动 Bash，保证用户可以使用 Shell。
如果一切正常，运行上面的命令以后，就会返回一个命令行提示符。
root@66d80f4aaf1e:/app#
这表示你已经在容器里面了，返回的提示符就是容器内部的 Shell 提示符。执行下面的命令。
root@66d80f4aaf1e:/app# node demos/01.js

10.4 CMD 命令
上一节的例子里面，容器启动以后，需要手动输入命令node demos/01.js。我们可以把这个命令写在 Dockerfile 里面，这样容器启动以后，这个命令就已经执行了，不用再手动输入了。
FROM node:8.4
COPY . /app
WORKDIR /app
RUN npm install --registry=https://registry.npm.taobao.org
EXPOSE 3000
CMD node demos/01.js
上面的 Dockerfile 里面，多了最后一行CMD node demos/01.js，它表示容器启动后自动执行node demos/01.js。

你可能会问，RUN命令与CMD命令的区别在哪里？简单说，RUN命令在 image 文件的构建阶段执行，执行结果都会打包进入 image 文件；CMD命令则是在容器启动后执行。另外，一个 Dockerfile 可以包含多个RUN命令，但是只能有一个CMD命令。
注意，指定了CMD命令以后，docker container run命令就不能附加命令了（比如前面的/bin/bash），否则它会覆盖CMD命令。现在，启动容器可以使用下面的命令。
$ docker container run --rm -p 8000:3000 -it koa-demo:0.0.1

10.5 发布 image 文件
容器运行成功后，就确认了 image 文件的有效性。这时，我们就可以考虑把 image 文件分享到网上，让其他人使用。
首先，去 hub.docker.com 或 cloud.docker.com 注册一个账户。然后，用下面的命令登录。

$ docker login
接着，为本地的 image 标注用户名和版本。

$ docker image tag [imageName] [username]/[repository]:[tag]
# 实例
$ docker image tag koa-demos:0.0.1 ruanyf/koa-demos:0.0.1
也可以不标注用户名，重新构建一下 image 文件。

$ docker image build -t [username]/[repository]:[tag] .
最后，发布 image 文件。

$ docker image push [username]/[repository]:[tag]
发布成功以后，登录 hub.docker.com，就可以看到已经发布的 image 文件。


基础操作：
1 docker images 查看镜像信息列表 镜像是静态的
2 docker ps -a 查看运行中的所有容器
3 docker pull  [images]:[version]从dockerhub拉取指定镜像

4 docker run -p 8000:80 -tdi --privileged [imageID] [command]  后台启动docker,并指定宿主机端口和docker映射端口。
 -i:以交互模式运行容器，通常与 -t 同时使用；
 -d:后台运行容器，并返回容器ID；
-t:为容器重新分配一个伪输入终端，通常与 -i 同时使用；
--privileged 容器将拥有访问主机所有设备的权限
通常情况下 [command] 填下 /bin/bash 即可。
特殊情况下，如需要在centos镜像中使用systemctl . 则应添加--privileged 并设置[command ]为 init。

5 当镜像通过run 启动后，便会载入到一个动态的container(容器)中运行，此时若需要进入终端交互模式：
sudo docker exec -it [containerID] /bin/bash
交互模式中，使用  ctrl+p+q退出交互 保持运行,使用 exit命令退出并停止容器。
6 在容器非交互模式下，通过docker  start/stop 命令来启动/停止已部署的容器服务。
7 docker rm [containerID] 删除容器
8 docker rmi [imageID] 删除镜像

9 docker cp [YourHostFilePath] [containerID]:[DockerPath]  将宿主机内的指定文件传输至容器内部的指定地址。
镜像制作：

1  docker commit [containerID] [ImageName]:[Version] 将修改后的容器重新打包成镜像

2 docker commit -a "runoob.com" -m "my apache" a404c6c174a2 mymysql:v1 将容器a404c6c174a2 保存为新的镜像,并添加提交人信息和说明信息。
-a :提交的镜像作者；
 -c :使用Dockerfile指令来创建镜像；
 -m :提交时的说明文字；
 -p :在commit时，将容器暂停。

3 docker push [ImageID] [repertory_address]提交镜像到云仓库






















