socket三元组：ip地址，协议，端口

一个Socket就是五元组：
1）协议；
2）本地地址；
3）外部地址；
4）状态；
5）PID。
PS：有的时候也被叫做四元组，四元组不包括协议。

tcp连接四元组： 1. 服务器的IP 2. 服务器的Port 3. 客户端的IP 4. 客户端的Port

位于应用层的应用程序在基于 TCP 协议或 UDP 协议进行通信时，需要用到操作系统提供的类库，这种类库一般称为 API（Application Programming Interface，应用编程接口）。
Socket（套接字）API

TCP 的服务端要先监听一个端口，一般是先调用 bind 函数，给这个 Socket 赋予一个 IP 地址和端口。
当服务端有了 IP 和端口号，就可以调用 listen 函数进行监听。在 TCP 的状态图里面，有一个 listen 状态，当调用这个函数之后，服务端就进入了这个状态，这个时候客户端就可以发起连接了。

在操作系统内核中，为每个 Socket 维护两个队列。一个是已经建立了连接的队列，这时候连接三次握手已经完毕，处于 established 状态；一个是还没有完全建立连接的队列，这个时候三次握手还没完成，处于 syn_rcv 的状态。
接下来，服务端调用 accept 函数，拿出一个已经完成的连接进行处理。如果还没有完成，就要等着。
在服务端等待的时候，客户端可以通过 connect 函数发起连接。先在参数中指明要连接的 IP 地址和端口号，然后开始发起三次握手，操作系统会给客户端分配一个临时的端口。一旦握手成功，服务端的 accept 就会返回另一个 Socket 用于传输数据。
这里需要注意的是，负责监听的 Socket 和真正用来传数据的 Socket 是两个，一个叫作监听 Socket，一个叫作已连接 Socket。
连接建立成功之后，双方开始通过 read 和 write 函数来读写数据，就像往一个文件流里面写东西一样。
说 TCP 的 Socket 就是一个文件流，是非常准确的。因为，Socket 在 Linux 中就是以文件的形式存在的。除此之外，还存在文件描述符。写入和读出，也是通过文件描述符。

注：如果你留心过 Nginx 里面 PHP-FPM 的配置，就会发现有两种方式将 PHP 动态请求转发给 PHP-FPM，一种是 IP 地址+端口号，例如：127.0.0.1:9000，一种是 Socket 文件，例如：unix:/run/php/php7.1-fpm.sock。这里也可以表明，Socket 在 Linux 中确实以文件形式存在，由于不需要建立额外的网络请求，所以后者效率更高，但是由于是本地文件，所以不能跨机器访问，如果 Nginx 和 PHP-FPM 部署在不同的机器，只能通过前一种方式转发请求。


服务器端 TCP 连接四元组中只有对端 IP 和对端端口（即客户端IP和端口）是可变的，因此，最大 TCP 连接数 = 客户端 IP 数 × 客户端端口数。对 IPv4，客户端的 IP 数最多为 2 的 32 次方，客户端的端口数最多为 2 的 16 次方，也就是服务端单机最大 TCP 连接数，约为 2 的 48 次方。
当然，服务端最大并发 TCP 连接数远不能达到理论上限。首先主要是文件描述符限制，按照前面介绍的原理，Socket 都是文件，所以首先要通过 ulimit 配置文件描述符的数目；另一个限制是内存，按上面的数据结构，每个 TCP 连接都要占用一定内存，操作系统是有限的。

为了尽可能多的让服务器提供更多连接，处理更多请求，通常有以下几种解决方案：
1、多进程
2、多线程
3、多路复用
上面基于进程或线程的模型还是有问题，因为每新进来一个 TCP 连接请求，就需要分配一个进程或线程，从而引发著名的 C10K 问题（一台机器要维护 1 万个连接，就要创建 1 万个进程或者线程，操作系统是无法承受的。如果维持 1 亿用户在线需要 10 万台服务器，成本也太高了）

多路复用
多路 IO 复用可以简单理解为一个线程维护多个 Socket（前面多进程或多线程都是一个进程或线程维护一个 Socket），这也有两种实现方式：轮询和事件通知。

因为 Socket 在 Linux 系统中以文件描述符形式存在，所以我们把一个线程维护的所有 Socket 叫做文件描述符集合，所谓轮询就是调用内核的 select 函数监听文件描述符集合是否有变化，一旦有变化，就会依次查看每个文件描述符，对那些发生变化的文件描述符进行读写操作，然后再调用 select 函数监听下一轮的变化。

显然，轮询的效率有点低，因为每次文件描述符集合有变化，都要将全部 Socket 轮询一遍，这大大影响了系统能够支撑的最大连接数。如果改成事件通知的方式，情况要好很多。所谓事件通知，就是某个文件描述符发生变化，调用 epoll 函数主动通知。这种方式使得监听的 Socket 数据增加的时候，效率不会大幅度降低，能够同时监听的 Socket 的数目也非常多。上限就为系统定义的、进程打开的最大文件描述符个数。
因此，epoll 被称为解决 C10K 问题的利器。




