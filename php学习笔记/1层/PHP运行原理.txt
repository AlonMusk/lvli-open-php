php的常用4种运行模式
1）cgi 通用网关接口（Common Gateway Interface)）
2） fast-cgi 常驻 (long-live) 型的 CGI
3） cli  命令行运行   （Command Line Interface）
4）web模块模式 （apache等web服务器运行的模块模式）

编译器的几个过程： 词法分析 语法分析 语义分析 中间代码生成 代码优化 目标代码生成

多线程模型
弱类型语言
引擎（zend）+组件（ext）降低内部耦合
中间层（sapi）隔绝webserver和php
语法灵活，导致风格混杂
php的四层体系（zend引擎+ext+sapi+上层应用）

1. php设计的原理和特点

多进程模型：这样能做到进程间互相不受影响，对于进程的资源利用更快速、便捷
弱类型语言：和强类型语言C、C++、java等语言不同，php中变量的类型并不是一开始就确定的，他是在运行时才确定的，可以隐式或显式的对其进行类型转换，这就使其在开发中非常的灵活，程序员无需关注变量类型的问题
Zend引擎+ 组件（ext）的模式降低内部的耦合
中间层（sapi）隔绝web server 和php
语法简单灵活，规范少。这一点就有利有弊了。。。

php从上到下一共四层体系：
Zend引擎：Zend整体用C实现，是php的内核部分，它将php的代码翻译成可执行的opcode的，处理并实现相应的处理方法（原理：鸟哥的博客）、实现了基本的数据结构、内存分配及管理、提供了相应api方法供外部使用，是一切的核心。

Extensions：围绕着Zend引擎，extensions通过组件的方式提供各种基础服务，常用的内置函数array、标准库等都是通过extension来实现的，用户也可以根据需要实现自己的extension以达到功能扩展等目的如贴吧正在使用的 PHP中间层、富文本解析就是extension的典型应用）。

Sapi：Sapi全称Server Application Programing Interface， 也就是服务端应用编程接口，Sapi通过一些列钩子函数，使php可以和外围交互数据，这是PHP非常优雅和成功的一个设计，通过 sapi成功的将PHP本身和上层应用解耦隔离，PHP可以不再考虑如何针对不同应用进行兼容，而应用本身也可以针对自己的特点实现不同的处理方式。

上层应用：这就是程序员编写的应用程序，通过不同的sapi方式得到各种各样的应用模式，如通过webserver实现web应用，在命令行下以脚本的方式运行等等

3. Sapi
如前所属，Sapi通过一些列的接口，使外部应用可以和php交换数据并可以根据不同的应用特点实现特定的处理方法，常见的sapi有：

apache2handler：以apache作为webserver，采用MOD_PHP模式运行时候的处理方式，也是现在应用最广泛的一种
cgi：这是webserver和php的另外一种交互方式，也就是fastcgi协议
cli：命令调试应用模式

4、php代码的执行流程
从图中可以看出，php通过Zend引擎实现了一个典型的动态语言的执行过程：获取一段代码片段，经过词法解析、语法解析等阶段，源程序被翻译成一个个指令（opcodes），然后Zend虚拟机顺序执行这些指令。PHP本身是用C语言实现的，因此最终调用的也是C语言的函数。
PHP的执行的核心是翻译出来的一条一条指令，也即opcode
Opcode是PHP程序执行的最基本单位。一个opcode由两个参数(op1,op2)、返回值和处理函数组成。PHP程序最终被翻译为一组opcode处理函数的顺序执行。
常用的几个函数：

END_ASSIGN_SPEC_CV_CV_HANDLER : 变量分配 （ a=b)
ZEND_DO_FCALL_BY_NAME_SPEC_HANDLER：函数调用
ZEND_CONCAT_SPEC_CV_CV_HANDLER：字符串拼接 a.b
ZEND_ADD_SPEC_CV_CONST_HANDLER: 加法运算a+2
ZEND_IS_EQUAL_SPEC_CV_CONST：判断相等 a==1
ZEND_IS_IDENTICAL_SPEC_CV_CONST：判断相等 a===1

5. Zend引擎介绍
Zend引擎作为php的内核，主要的设计机制有：
5.1  实现HashTable数据结构
HashTable是Zend的核心数据结构，在php里面几乎用来实现所有功能，php的数据array()就是典型的应用。此外在Zend内部，如函数符号表、全景变量都是通过HashTable来实现的。
Zend hash table 实现了典型的hash表散列结构，同时通过附加一个双向链表，提供了正向、反向、遍历数组的功能，结构如图：

可以看到，在hash table中既有key->value形式的散列结构，也有双向链表模式，使得它能够非常方便的支持快速查找和线性遍历。
** 散列结构**：Zend的散列结构是典型的hash表模型，通过链表的方式来解决冲突。需要注意的是zend的hash table是一个自增长的数据结构，当hash表数目满了之后，其本身会动态以2倍的方式扩容并重新元素位置。初始大小均为8。另外，在进行 key->value快速查找时候，zend本身还做了一些优化，通过空间换时间的方式加快速度。比如在每个元素中都会用一个变量 nKeyLength标识key的长度以作快速判定。
双向链表：Zend hash table通过一个链表结构，实现了元素的线性遍历。理论上，做遍历使用单向链表就够了，之所以使用双向链表，主要目的是为了快速删除，避免遍历。 Zend hash table是一种复合型的结构，作为数组使用时，即支持常见的关联数组也能够作为顺序索引数字来使用，甚至允许2者的混合。
PHP关联数组：关联数组是典型的hash_table应用。一次查询过程经过如下几步（从代码可以看出，这是一个常见的hash查询过程并增加一些快速判定加速查找）：

01  getKeyHashValue h;
02  index = n & nTableMask;
03  Bucket *p = arBucket[index];
04  while (p) {
05      if ((p->h == h) && (p->nKeyLength == nKeyLength)) {
06          RETURN p->data;   
07      }
08      p=p->next;
09  }
10  RETURN FALTURE;

PHP索引数组：索引数组就是我们常见的数组，通过下标访问。例如 arr[0]，Zend HashTable内部进行了归一化处理，对于index类型key同样分配了hash值和nKeyLength(为0)。内部成员变量 nNextFreeElement就是当前分配到的最大id，每次push后自动加一。正是这种归一化处理，PHP才能够实现关联和非关联的混合。由于 push操作的特殊性，索引key在PHP数组中先后顺序并不是通过下标大小来决定，而是由push的先后决定。例如 arr[1] = 2; arr[2] = 3;对于double类型的key，Zend HashTable会将他当做索引key处理

5.2 PHP变量的实现原理
PHP是一门弱类型语言，不严格区分变量的类型。PHP的变量可以分为简单类型（int、sting、bool）、集合类型(array, resource, object) 和常量(const)，所有的变量在底层都所以同一种结构zval
zval是zend中非常重要的数据结构，用来标示并实现php的变量，其数据结构如下：
struct _zval_struct {
    zvalue_value value;     /* value */
    zend_uint refcount__gc;  /* variable ref count */
    zend_uchar type;          /* active type */
    zend_uchar is_ref__gc;    /* if it is a ref variable */
};
typedef struct _zval_struct zval;

其中，


zval_value value是变量的实际值，具体来说是一个zvalue_value联合体：

typedef union _zvalue_value {
    long lval;                  /* long value */
    double dval;                /* double value */
    struct {                    /* string */
        char *val;
        int len;
    } str;
    HashTable *ht;              /* hash table value,used for array */
    zend_object_value obj;      /* object */
} zvalue_value;

zend_uint refcount__gc是一个计数器，用来保存多少变量（或者符号，symbols ）指向了该zval。在变量生成时，其refcount=1，典型的赋值操作如$a = $b会令zval的refcount加1，而unset操作会相应的减1。在PHP5.3之前，使用引用计数的机制来实现GC，如果一个zval的refcount较少到0，那么Zend引擎会认为没有任何变量指向该zval，因此会释放该zval所占的内存空间。但，事情有时并不会那么简单。后面我们会看到，单纯的引用计数机制无法GC掉循环引用的zval，即使指向该zval的变量已经被unset，从而导致了内存泄露（Memory Leak）。

zend_uchar type该字段用于表明变量的实际类型。PHP中的变量包括四种标量类型（bool,int,float,string），两种复合类型（array, object）和两种特殊的类型（resource 和NULL）。在zend内部，这些类型对应于下面的宏（代码位置 phpsrc/Zend/zend.h）

#define IS_NULL     0
#define IS_LONG     1
#define IS_DOUBLE   2
#define IS_BOOL     3
#define IS_ARRAY    4
#define IS_OBJECT   5
#define IS_STRING   6
#define IS_RESOURCE 7
#define IS_CONSTANT 8
#define IS_CONSTANT_ARRAY   9
#define IS_CALLABLE 10



is_ref__gc这个字段用于标记变量是否是引用变量。对于普通的变量，该值为0，而对于引用型的变量，该值为1。这个变量会影响zval的共享、分离等

5.2.1 整数、浮点数变量
整数、浮点数是PHP中的基础类型之一，也是一个简单型变量。对于整数和浮点数，在zvalue中直接存储对应的值。其类型分别是long和double。
从zvalue结构中可以看出，对于整数类型，和c等强类型语言不同，PHP是不区分int、unsigned int、long、long long等类型的，对它来说，整数只有一种类型也就是long。由此，可以看出，在PHP里面，整数的取值范围是由编译器位数来决定而不是固定不变的。在php中如果整数越界了会发生什么？php会自动给整数转换成浮点数类型
对于浮点数，类似整数，它也不区分float和double而是统一只有double一种类型
5.2.2 字符变量
和整数一样，字符变量也是PHP中的基础类型和简单型变量。通过zvalue结构可以看出，在PHP中，字符串是由由指向实际数据的指针和长度结 构体组成，这点和c++中的string比较类似。由于通过一个实际变量表示长度，和c不同，它的字符串可以是2进制数据（包含\0），同时在PHP中， 求字符串长度strlen是O(1)操作

常见的字符串拼接方式及速度比较：
假设有如下4个变量：strA=‘123’; strB = ‘456’; intA=123; intB=456;
现在对如下的几种字符串拼接方式做一个比较和说明：
1 res = strA.strB和res = “strAstrB”
这种情况下，zend会重新malloc一块内存并进行相应处理，其速度一般。
2 strA = strA.strB
这种是速度最快的，zend会在当前strA基础上直接relloc，避免重复拷贝
3 res = intA.intB
这种速度较慢，因为需要做隐式的格式转换，实际编写程序中也应该注意尽量避免
4 strA = sprintf (“%s%s”,strA，strB);
这会是最慢的一种方式，因为sprintf在PHP中并不是一个语言结构，本身对于格式识别和处理就需要耗费比较多时间，另外本身机制也是malloc。不过sprintf的方式最具可读性，实际中可以根据具体情况灵活选择。

5.2.3 数组变量
PHP的数组是通过Zend Hash Table来天然实现。
foreach操作如何实现？对一个数组的foreach就是通过遍历hashtable中的双向链表完成。对于索引数组，通过foreach遍 历效率比for高很多，省去了key->value的查找。count操作直接调用 HashTable->NumOfElements，O(1)操作。对于’123’这样的字符串，zend会转换为其整数形 式。arr[‘123’]和arr[123]
5.3 PHP变量管理-引用计数和写时拷贝
引用计数在内存回收、字符串操作等地方使用非常广泛。Zval的引用计数通过成员变量is_ref和ref_count实现，通过引用计数，多个变量可以共享同一份数据。避免频繁拷贝带来的大量消耗。在进行赋值操作时，zend将变量指向相同的zval同时ref_count++，在unset操作时，对应的ref_count-1。只有ref_count减为0时才会真正执行销毁操作。如果是引用赋值，则zend会修改is_ref为1。

PHP变量通过引用计数实现变量共享数据，那如果改变其中一个变量值呢？当试图写入一个变量时，Zend若发现该变量指向的zval被多个变量共享，则为其复制一份ref_count为1的zval，并递减原zval的refcount，这个过程称为“zval分离”。可见，只有在有写操作发生时 zend才进行拷贝操作，因此也叫copy-on-write(写时拷贝)
对于引用型变量，其要求和非引用型相反，引用赋值的变量间必须是捆绑的，修改一个变量就修改了所有捆绑变量。
5.4 PHP局部变量和全局变量的实现：
PHP中的局部变量和全局变量是如何实现的？对于一个请求，任意时刻PHP都可以看到两个符号表(symbol_table和 active_symbol_table)，其中前者用来维护全局变量。后者是一个指针，指向当前活动的变量符号表，当程序进入到某个函数中时，zend 就会为它分配一个符号表x同时将active_symbol_table指向a。通过这样的方式实现全局、局部变量的区分。
获取变量值：PHP的符号表是通过hash_table实现的，对于每个变量都分配唯一标识，获取的时候根据标识从表中找到相应zval返回。

函数中使用全局变量：在函数中，我们可以通过显式申明global来使用全局变量。在active_symbol_table中创建symbol_table中同名变量的引用（引用变量的值要更新大家会一起更新），如果symbol_table中没有同名变量则会先创建。

PHP-CGI就是PHP实现的自带的FastCGI管理器

PHP-FPM
PHP-FPM是一个PHP FastCGI管理器.PHP-FPM其实是PHP源代码的一个补丁，旨在将FastCGI进程管理整合进PHP包中

FastCGI的工作原理
Web Server启动时载入FastCGI进程管理器（IIS ISAPI或Apache Module)
FastCGI进程管理器自身初始化，启动多个CGI解释器进程(可见多个php-cgi)并等待来自Web Server的连接。
当客户端请求到达Web Server时，FastCGI进程管理器选择并连接到一个CGI解释器。Web server将CGI环境变量和标准输入发送到FastCGI子进程php-cgi。
FastCGI子进程完成处理后将标准输出和错误信息从同一连接返回Web Server。当FastCGI子进程关闭连接时，请求便告处理完成。FastCGI子进程接着等待并处理来自FastCGI进程管理器(运行在Web Server中)的下一个连接。 在CGI模式中，php-cgi在此便退出了。
在上述情况中，你可以想象CGI通常有多慢。每一个Web请求PHP都必须重新解析php.ini、重新载入全部扩展并重初始化全部数据结构。使用FastCGI，所有这些都只在进程启动时发生一次。一个额外的好处是，持续数据库连接(Persistent database connection)可以工作。

FastCGI的不足
因为是多进程，所以比CGI多线程消耗更多的服务器内存，PHP-CGI解释器每进程消耗7至25兆内存，将这个数字乘以50或100就是很大的内存数。
由于FastCGI是多进程，所以比CGI多线程消耗更多的服务器内存，php-cgi解释器每进程消耗7至25兆内存，将这个数字乘以50或100就是很大的内存数。


Nginx 0.8.46+PHP 5.2.14(FastCGI)服务器在3万并发连接下，开启的10个Nginx进程消耗150M内存（15M*10=150M），开启的64个php-cgi进程消耗1280M内存（20M*64=1280M），加上系统自身消耗的内存，总共消耗不到2GB内存。如果服务器内存较小，完全可以只开启25个php-cgi进程，这样php-cgi消耗的总内存数才500M。
上面的数据摘自Nginx 0.8.x + PHP 5.2.13(FastCGI)搭建胜过Apache十倍的Web服务器(第6版)